<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- 사용법을 기억은 못해도 어떤 기능이 있는지는 알아둬야함 -->
  <script>
    // 3. Array 객체
    // 여러 데이터를 순차적으로 저장 가능한 객체로 배열을 다룰 때 유용한 속성과 함수를 제공
    // 배열 객체 생성 3가지 방식
    // 첫번째 방식
    // const 변수 = new Array(값1, 값2, 값3);

    // 두번째 방식
    // const 변수 = new Array();
    // 변수[0] = 값1;
    // 변수[1] = 값2;
    // 변수[2] = 값3;

    // 세번째 방식 (제일 많이쓰는거)
    // const 변수 = [값1, 값2, 값3]; => 리터럴 방식

    document.write('<h1>Array 객체</h1>');
    const arr = ['Apple', 'Banana', 'Mango'];
    

    // 배열 요소 변경
    // 인덱스로 접근해서 새로운 요소를 할당
    arr[0] = 'Kiwi';
    console.log(arr);
    

    // 배열 요소 접근 (가져오는 방법이 여러개 있음)
    document.write('<h4>배열값 가져오기-1</h4>');
    document.write(arr[0], '<br>');
    document.write(arr[1], '<br>');
    document.write(arr[2], '<br>');

    document.write('<h4>배열값 가져오기-2</h4>');
    // Quiz: 일반 for문
    for (let i = 0; i < arr.length; i++) {
      // const element = arr[i];
      document.write(arr[i], '<br>');
    }

    document.write('<h4>배열값 가져오기-3(권장 안함)</h4>'); // 배열에서는 성능때문에 권장안하는 거임
    for (const i in arr) { // arr객체로부터 Key값(배열에선index)을 가져옴
      document.write(arr[i], '<br>');
    }

    document.write('<h4>배열값 가져오기-4</h4>');
    for (const el of arr) { // Value 값을 가져옴, ES6차 문법(자바에서 향상된for문(for-each)과 똑같음)
      document.write(el, '<br>')
    }

    document.write('<h4>배열값 가져오기-5</h4>');
    // Quiz: 배열의 forEach() 메소드
    // const ela = document.querySelectorAll(arr);
      arr.forEach (function(element, index){
        document.write(`${index}: ${element}<br>`)
      // document.writeln(ele, '<br>');
    });

    // 1) toString()
    // 배열 안의 모든 요소를 쉼표(,)를 이용해 결합해서 하나의 문자열로 반환
    let fruits = ['Banana', 'Orange', 'Apple', 'Mango'];
    console.log(fruits.toString()); // Banana,Orange,Apple,Mango

    // 2) join()
    // 배열 안의 모든 요소를 지정한 문자를 이용해 결합해서 하나의 문자열로 반환
    console.log(fruits.join(' * ')); // Banana * Orange * Apple * Mango
    // 실무 사용 사례: 
    // - 문자열을 합쳐야 하는 경우, 더하기(+)를 이용해서 문자열을 합칠 수도 있지만, 합쳐야 할 문자열이 많은 경우
    // 합쳐야 할 문자열을 배열에 넣고, 나중에 한번에 join() 함수를 사용해서 합치는 것이 프로그램 성능면에서 우수

    // 3) pop()
    // 배열에서 마지막 요소를 제거하고, 마지막 요소를 반환
    // 원본 배열이 변경됨
    let x = fruits.pop();
    console.log(x); // 맨 뒤에 있던 Mango 반환
    console.log(fruits); // 원본 배열이 변경되었다.
    
    

    // 4) shift()
    // 배열에서 첫 번째 요소를 제거하고, 첫 번째 요소를 반환
    // 원본 배열이 변경됨
    x = fruits.shift();
    console.log(x); // 맨 앞에 있던 Banana 반환
    console.log(fruits);

    // 5) push()
    // 배열에 맨 뒤에 새로운 요소를 추가하고, 배열의 길이를 반환
    // 원본 배열이 변경됨
    let ln = fruits.push('Mango'); // 맨 뒤에 망고 추가
    console.log(fruits); // 오렌지, 애플, 망고 들어가있음
    console.log(ln); // 길이 3
    
    // 실무 사용 사례: 
    // - 쇼핑몰에서 장바구니 기능을 구현할 때 장바구니에 제품 목록을 배열로 저장할 수 있음
    // 고객이 제품을 선택하고 장바구니 추가 버튼을 누를 때마다 배열의 push() 함수를 이용해서 추가

    // 6) unshift()
    // 배열의 맨 앞에 요소를 추가하고, 배열의 길이를 반환
    // 원본 배열이 변경됨
    ln = fruits.unshift('Banana');
    console.log(fruits); // 바나나 오렌지 애플 망고
    console.log(ln); // 길이 4


    // 실무 사용 사례: 
    // - 데이터베이스에서 지역 목록을 가져온 후, 가져온 지역 목록을 <select> 태그의 <option> 태그로 추가하려고 할 때
    // 사용자에게 제일 먼저 보이는 옵션은 '지역을 선택하세요'라는 정보성 옵션을 구성하는 경우가 많음
    // 이럴 때 데이터베이스에서 가져온 목록의 배열 첫 요소로 '선택하세요'라는 정보성 옵션을 unshift() 함수로 쉽게 추가

    // 7) splice()
    // 새로운 요소를 특정 위치에 추가하거나 기존 요소를 삭제할 수도 있음
    // 원본 배열이 변경됨
    // array.splice(index, howmany, item1, ....., itemX)
    // index: 항목을 추가하거나 제거할 인덱스 번호
    // howmany: 제거할 항목 수 ....항목을 제거 하기싫다면 0을 넣는다.
    // 나머지 파라미터: 추가할 새 요소
    fruits.splice(2, 0, 'Lemon', 'Kiwi');
    console.log(fruits); // 바나나 오렌지 레몬 키위 애플 망고

    // 실무 사용 사례: 
    // - 일반적으로 테이블 목록 같은 데이터는 배열 형태로 관리됨
    // 테이블에서 특정 행을 선택하고 '행 추가' 버튼을 누르면 현재 선택된 행의 인덱스 번호를 기준으로 새로운 행을 추가해야 함
    // 이때 splice() 함수를 사용

    // 8) concat()
    // 2개 이상의 배열을 하나의 배열로 결합
    // '새로운 배열'로 반환..............원본이 바뀌는게 아니라 새롭게 만들기 때문에 변수를 하나 만들어줘야겠지
    const arr1 = ['Cecilie', 'Lone'];
    const arr2 = ['Emil', 'Tobias', 'Linus'];
    const arr3 = ['Robin', 'Morgan'];
    const myChildren = arr1.concat(arr2, arr3); // 변수 지정해야 함에 주의
    console.log(myChildren); // ['Cecilie', 'Lone', 'Emil', 'Tobias', 'Linus', 'Robin', 'Morgan']
    

    // 9) slice()
    // 지정된 시작과 끝 위치(포함되지 않음) 구간만큼 잘라내서 반환
    // '새로운 배열'로 반환
    // array.slice(start = 0, end = last element) .....end를 안적으면 끝까지 잘라냄
    fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
    const citrus = fruits.slice(3); // 시작 인덱스에서 마지막 배열 요소까지 잘라내서 반환
    console.log(citrus);
    const citrus2 = fruits.slice(1, 3);
    console.log(citrus2);
    

    // 10) sort()
    // 배열에 문자형 데이터가 있는 경우 오름차순으로 정렬
    // 원본 배열이 변경됨
    fruits = ['Banana', 'Orange', 'Apple', 'Mango'];
    fruits.sort();
    console.log(fruits);
    
    

    // 배열 안에 숫자형 데이터가 있더라도 기본적으로는 문자로 인식해서 오름차순으로 정렬
    const points = [40, 100, 1, 5, 25, 10];
    points.sort();
    console.log(points);
    
    
    // '25'는 '100'보다 크다. 왜냐하면 '2'가 '1'보다 크기 때문
    // 그래서 숫자 값으로 정렬하려면 정렬(비교) 함수를 정의해서 사용해야 함
    // array.sort(정렬함수);
    // 정렬함수: function(a, b) { return a - b; }
    points.sort(function (a, b) {
      return a - b;
    });
    console.log(points);
    

    // 정렬 원리
    // returned (negative, zero, positive) value
    // 음수가 나오면 a, b 순으로 두 요소의 위치를 바꾸지 않음
    // 양수가 나오면 b, a 순으로 두 요소의 위치를 바꿈
    // 0이 나오면 변화 없음
    // Step 1: 첫 번째와 두 번째 요소를 비교. 40 - 100 = -60 음수이므로 두 요소의 위치를 바꾸지 않음
    // Step 2: 두 번째와 세 번째 요소를 비교. 100 - 1 = 99 양수이므로 두 요소의 위치를 바꿈
    // Step 3: 세 번째와 네 번째 요소를 비교. 100 - 5 = 95 양수이므로 두 요소의 위치를 바꿈
    // Step 4: 네 번째와 다섯 번째 요소를 비교. 100 - 25 = 75 양수이므로 두 요소의 위치를 바꿈
    // Step 5: 다섯 번째와 여섯 번째 요소를 비교. 100 - 10 = 90 양수이므로 두 요소의 위치를 바꿈
    // Step 6: 1번에서 5번 과정을 반복적으로 수행하면서 더 이상 요소 간의 위치 변경이 없을 때까지 진행
    // Step 7: 최종적으로 [1, 5, 10, 25, 40, 100] 결과를 얻음

    // Quiz: 숫자 데이터 내림차순 정렬하기
    points.sort(function (a, b) {
      return b - a;
    });
    console.log(points);

    // 활용 Tip!
    // 실무에서는 Object의 특정 키를 기준으로 sort() 함수를 사용하는 경우가 많음
    // 예: 쇼핑몰 상품 목록에서 가격 높은 순, 낮은 순, 리뷰 많은 순, 누적 판매 순
    // Quiz: 아래 사람들을 점수가 높은 순으로 정렬하기
    const persons = [
      {
        name: '유재석',
        point: 78,
        city: '서울',
      },
      {
        name: '김종국',
        point: 92,
        city: '서울',
      },
      {
        name: '양세찬',
        point: 76,
        city: '제주',
      },
      {
        name: '하하',
        point: 81,
        city: '서울',
      },
    ];

    persons.sort(function (a, b) {
      // console.log(a);
      // console.log(b);  // 무엇이 들어오는지 체크해보자
  
      // return a.point - b.point; // 이렇게 한줄로 가능
      
      // 단순 대소 비교가 아닌 더 복잡한 조건일 때 응용 가능!
      if (a.point > b.point) return -1; // 위치를 바꾸지 않음
      else if (a.point < b.point) return 1; // 위치를 바꿈
      else return 0; // 변화 없음
    });
    console.log(persons);

    // 11) reverse()
    // 배열의 순서를 반대로 바꿈
    // 원본 배열이 변경됨
    // 보통 정렬된 배열을 역순으로 정렬할 때 사용
    fruits = ['Banana', 'Orange', 'Apple', 'Mango'];
    fruits.sort();
    console.log(fruits); // 애플 바나나 망고 오렌지 (알파벳 순)
    fruits.reverse();
    console.log(fruits); // 오렌지 망고 바나나 애플 (알파벳의 역순)
    

    // 12) indexOf(), lastIndexOf()
    // 배열 안에 특정 요소가 존재하는지를 찾고, 
    // 찾으면 첫번째 인덱스(위치)를 반환
    // 찾을 수 없는 경우 -1을 반환
    fruits = ['Banana', 'Orange', 'Apple', 'Mango', 'Apple'];
    let index = fruits.indexOf('Apple');
    console.log(index);
    index = fruits.indexOf('Apple', 3); // 검색 시작 위치 지정
    console.log(index);
    index = fruits.lastIndexOf('Apple'); // 뒤에서 부터 검색
    console.log(index);

    // (ES7차) includes()
    // 지정된 값이 포함된 경우 true를 반환
    // 포함되지 않은 경우 false를 반환
    let has = fruits.includes('Mango');
    console.log(has);
    has = fruits.includes('Banana', 3); // 검색 시작 위치 지정 (3번 인덱스 이후부터 찾아라)
    console.log(has);
    
  </script>
</body>
</html>